---
title: "Untitled"
output: html_document
date: "2025-12-15"
---


```{r setup}

# To clear your environment 
remove(list = ls())

# load common packages
library(here)
here()
source(here('code', 'func_packages.R'))

```



```{r}
library(sf)
library(terra)
library(dplyr)
library(fasterize) # specialized package for fast polygon-to-raster conversion

# --- 1. Load Data ---
# Replace these paths with your actual file locations
path_trees <- "G:/Shared drives/Wellcome Trust Project Data/0_source_data/uk_shapefile_TCC24/TreeCanopyCover24_stitched.shp" 
#' lsoa data with quintiles info, which was generated by `socio-economic-data-ES-equity.Rmd`
path_lsoa <- './data/Social_Vulnerability_Index_london_q.gpkg'


message("Loading datasets...")
trees_sf <- st_read(path_trees, quiet = TRUE)
lsoa_sf  <- st_read(path_lsoa, quiet = TRUE)

# --- 2. Check and Align CRS ---
# Ensure both layers use the same projected coordinate system (e.g., British National Grid)
target_crs <- 27700 # EPSG for British National Grid

if (st_crs(lsoa_sf)$epsg != target_crs) {
  message("Reprojecting LSOA to British National Grid...")
  lsoa_sf <- st_transform(lsoa_sf, target_crs)
}

if (st_crs(trees_sf)$epsg != target_crs) {
  message("Reprojecting Trees to British National Grid...")
  trees_sf <- st_transform(trees_sf, target_crs)
}

# --- 3. Rasterization (The Fast Method) ---
message("Creating 1m resolution template raster...")
# Create a template raster covering the LSOA extent with 1m resolution
r_template <- rast(ext(lsoa_sf), resolution = 1, crs = st_crs(lsoa_sf)$wkt)

message("Rasterizing tree polygons (this may take a moment)...")
# converting sf to dataframe for fasterize if needed, though fasterize accepts sf directly
# We burn '1' where trees exist. background is NA (or 0)
trees_raster <- fasterize(trees_sf, raster(r_template), field = NULL, background = 0)
# Convert back to terra object for zonal stats
trees_terra <- rast(trees_raster)

# --- 4. Calculate Zonal Statistics ---
message("Calculating tree cover per LSOA...")

# 'zonal' sums the pixel values (1s) within each LSOA polygon
# exact=TRUE calculates partial pixel coverage for higher accuracy at borders
stats <- extract(trees_terra, lsoa_sf, fun = sum, na.rm = TRUE, bind = TRUE)

# The result is a SpatVector (terra object), convert back to sf to clean up
lsoa_results <- st_as_sf(stats)

# Rename the column generated by extract (usually matches the raster layer name, e.g. 'layer')
# Let's assume the count column is the last one added
count_col_name <- names(lsoa_results)[ncol(lsoa_results) - 1] # -1 because geometry is last

lsoa_results <- lsoa_results %>%
  rename(tree_area_m2 = all_of(count_col_name)) %>%
  mutate(
    lsoa_area_m2 = st_area(geometry),
    lsoa_area_m2 = as.numeric(lsoa_area_m2), # Drop units class for calculation
    tree_pct = (tree_area_m2 / lsoa_area_m2) * 100
  )

# --- 5. Clean and Save ---
# Select only relevant columns (LSOA ID, Name, Percentage)
final_output <- lsoa_results %>%
  select(LSOA_CODE, LSOA_NAME, tree_area_m2, lsoa_area_m2, tree_pct) # Adjust column names as per your data

output_filename <- "GLA_Tree_Cover_by_LSOA.gpkg"
message(paste("Saving result to", output_filename))

st_write(final_output, output_filename, driver = "GPKG", delete_dsn = TRUE)

message("Done!")
```

