---
title: "Untitled"
output: html_document
date: "2025-09-05"
---


  This script prepares average NDVI by postcode region.

  - Postcodes are used as keys to join with spatial data and obtain coordinates.
  
  - Because only postcode points are available, 300 m buffer zones are created as proxies for postcode areas.
  
  - These buffered polygons are then uploaded to GEE to extract NDVI values.
  

```{r include=FALSE}

library(readr)
library(dplyr)
library(sf)
library(lubridate)
library(writexl)
library(ggplot2)

library(purrr)
library(tidyr)
library(stringr)

ymd <- format(Sys.time(), "%Y%m%d"); ymd
```



## Load data and pre-cleaning

```{r social mind data}

dir <- "G:/Shared drives/Wellcome Trust Project Data/0_source_data/"

dir.sm <- file.path(dir, 'SocialMind', 'Participant Postcodes Updated.xlsx')
dir.postcode <- file.path(dir, 'Geolocation Data', 'london_postcode.csv')

sm <- readxl::read_excel(dir.sm) %>%
  ## remove space in `Postcode`
  mutate(Postcode = gsub(" ", "", Postcode)) %>%
  rename('Baseline_Date' = 'Baseline Date') %>%
  mutate(Baseline_Date = as.Date(Baseline_Date)) %>%
  # filter(!is.na(Baseline_Date)) %>%
  filter(!is.na(Postcode)) %>%
  # arrange(!is.na(Postcode)) %>%
  as.data.frame()

sm_code <- sm %>%
  distinct(Postcode)
```


```{r postcode data}

## data 1: by Yougeng - not complete 
code <- read_csv(dir.postcode, show_col_types = FALSE) %>%
  select(Postcode, Latitude, Longitude)

names(sm)
names(code)


## data 2: uk, 2025
##' source: https://docs.google.com/document/d/1ol-RXiUA7Yn24qyoo2PtWeQZvxUTVQwLw61KzqToc1k/edit?usp=sharing


# Use forward slashes or double backslashes in Windows paths
gpkg_path <- "E:/London/UK_postcode_shp/codepo_gpkg_gb/Data/codepo_gb.gpkg"

# # Read the GeoPackage (defaults to the first layer if none specified)
# code_uk <- st_read(gpkg_path)
# code_uk_sub <- code_uk %>%
#   select(postcode, admin_district_code, admin_ward_code) %>%
#   rename('Postcode' = 'postcode') %>%
#   ## remove space in `Postcode`
#   mutate(Postcode = gsub(" ", "", Postcode)) 
# 
# 
# ## Make sure your data is in WGS84 (EPSG:4326) if you want real-world lon/lat
# code_uk_coord <- st_transform(code_uk_sub, 4326) 
# 
# code_uk_coord <- code_uk_coord %>%
#   mutate(
#     lon = st_coordinates(.)[,1],
#     lat = st_coordinates(.)[,2]
#   )
# 
# names(code_uk)
# 
# f <- paste0(dirname(gpkg_path), '/', gsub('_gb.gpkg', '_gb_coordinates.rds', basename(gpkg_path))); f
# saveRDS(code_uk_coord, f)


## load data
f <- paste0(dirname(gpkg_path), '/', gsub('_gb.gpkg', '_gb_coordinates.rds', basename(gpkg_path))); f
code_uk_coord <- readRDS(f)
 
```


```{r join data}

# ## data 1: a lot of missing postcode ... cannot be used ...
# sm_code_xy <- sm_code %>%
#   left_join(., code, by = "Postcode") %>%
#   arrange(!is.na(Postcode), !is.na(Latitude))
# 
# sm_code_xy %>%
#   summarise(
#     na_count = sum(is.na(Latitude)),
#     non_na_count = sum(!is.na(Latitude))
#   )




## data 2: better but still have 20 missing ones - need to check with KCL team later
sm_code_xy <- sm_code %>%
  # filter(!is.na(Postcode)) %>%
  left_join(., 
            code_uk_coord %>% st_drop_geometry(), 
            by = "Postcode") %>%
  arrange(!is.na(Postcode), !is.na(admin_ward_code))

sm_code_xy %>%
  summarise(
    na_count = sum(is.na(admin_ward_code)),
    non_na_count = sum(!is.na(admin_ward_code))
  )
```


```{r join data - unmatched}

## save the unmatched data and send to collaborator
postcode_unmatched <- sm_code_xy %>%
  filter(is.na(lon)) %>%
  select(-admin_ward_code, -admin_district_code)

sm_unmatched <- sm %>% 
  # filter(!is.na(Postcode)) %>%
  filter(Postcode %in% unique(postcode_unmatched$Postcode)) %>%
  # distinct(Postcode, .keep_all = T) %>%
  arrange(!is.na(Postcode), Postcode)

## 
f <- file.path(dir, 'SocialMind', 'output', paste0('postcode_unmatched_', ymd, '.xlsx')); f
writexl::write_xlsx(x = postcode_unmatched, path = f)

f <- file.path(dir, 'SocialMind', 'output', paste0('postcode_unmatched_Participant_', ymd, '.xlsx')); f
writexl::write_xlsx(x = sm_unmatched, path = f)
```



```{r sf with buffer}

# Convert to sf
sm_postcode_shp <- sm_code_xy %>%
  filter(!is.na(lon)) %>%
  select(-admin_ward_code, -admin_district_code) %>%
  st_as_sf(., coords = c("lon", "lat"), crs = 4326, remove = FALSE)  # WGS84

# plot(sm_postcode_shp[1])



# 1. Reproject to a CRS in meters (here: British National Grid, EPSG:27700)
pts_m <- st_transform(sm_postcode_shp, 27700)

# 2. Create 300 m buffer
buffers <- st_buffer(pts_m, dist = 300) %>%
  mutate(buffer_m = 300)

# 3. (Optional) Transform back to WGS84 for mapping
##'   Warning: All vector data in Earth Engine is stored in a spherical coordinate system (specifically, EPSG:4326).To minimize the possibility of unintended changes, first reproject vector data to EPSG:4326 before uploading.
buffers_wgs84 <- st_transform(buffers, 4326)



## save data

f <- file.path(dir, 'SocialMind', 'output', 'sm_postcode_pt_300m.rds'); f
saveRDS(buffers_wgs84, f)


f <- file.path(dir, 'SocialMind', 'output', 'sm_postcode_pt_300m.gpkg'); f
st_write(buffers_wgs84, f, delete_layer = TRUE)


## --> only shp format can be uploaded to GEE
f <- file.path(dir, 'SocialMind', 'output', 'sm_postcode_pt_300m.shp'); f
st_write(buffers_wgs84, f, delete_layer = TRUE)

```




The seasonal division is consistent with Yougengâ€™s earlier approach

  Spring: 3/1 - 6/1
  Summer: 6/1 - 9/1
  Fall:   9/1 - 12/1
  Winter: 12/1 - 3/1
  
  
## For GEE

Then upload the shapefile data to GEE, and use GEE to calculate NDVI by postcode region 

The GEE script name is `london_urban_cooling/SocialMind_postcodeNDVI`

```{r}

```





## Merge NDVI back to the original data

```{r - code with date}

sm_date <- sm %>%
  filter(!is.na(Baseline_Date)) %>%
  as.data.frame()


sm_date_summary <- sm_date %>%
  group_by(Baseline_Date) %>%
  count() %>%
  ungroup() %>%
  as.data.frame() 

sm_date_summary %>%
  ggplot() + 
  geom_point(aes(x = Baseline_Date, y = n)) +
  theme_minimal()
```


```{r}

## 1. load NDVI data from GEE
dir.ndvi <- 'G:/My Drive/SocialMind'

## test
# ndvi <- read_csv(file = file.path(dir.ndvi, 'sm_postcode_ndvi_2019_Fall.csv'), show_col_types = F) %>%
#   select(Postcode, ndvi_mean, season, date_ini, date_end)



## 1.2 load all

files <- list.files(
  path   = dir.ndvi,
  pattern = "^sm_postcode_ndvi.*\\.csv$",
  full.names = TRUE
) 



ndvi <- files %>%
  map_dfr(~ read_csv(.x, show_col_types = FALSE) %>%
            select(Postcode, ndvi_mean, season, date_ini, date_end)) %>%
  mutate(year = lubridate::year(date_end))



# yr <- str_extract(files[1], "\\d{4}"); yr
yrs <- paste(sort(unique(ndvi$year)), collapse = '_')


ndvi_season <- ndvi %>%
  mutate(year_season = paste0(year, '_', season)) %>%
  select(-date_ini, -date_end, -year, -season) %>%
  tidyr::pivot_wider(names_from = year_season, values_from = ndvi_mean) %>%
  mutate(buffer_m = 300,
         ndvi_type = 'mean') %>%
  select(Postcode, 
         buffer_m, ndvi_type,
         # Winter, Spring, Summer, Fall, 
         everything())
  



## 2. merge NDVI to the original SM data
sm_ndvi <- sm %>%
  mutate(
    # year_baseline = year(Baseline_Date),
    year_season_baseline = case_when(
      !is.na(Baseline_Date) ~ paste(
        year(Baseline_Date),
        case_when(
          month(Baseline_Date) %in% 3:5  ~ "Spring",
          month(Baseline_Date) %in% 6:8  ~ "Summer",
          month(Baseline_Date) %in% 9:11 ~ "Fall",
          month(Baseline_Date) %in% c(12,1,2) ~ "Winter"
        ),
        sep = "_"
      ),
      TRUE ~ NA_character_
    )
  ) %>%
  
  left_join(., ndvi_season, by = 'Postcode') %>%
  pivot_longer(names_to = 'year_season_ndvi', values_to = 'ndvi_mean', cols = `2021_Fall`:last_col()) %>%
  # arrange(Subject_ID) %>%
  
  ##' if `year_season_baseline` is available, keep ndvi for that `season` only; 
  ##' if `year_season_baseline` is NA, then keep the ndvi for that `year`
  filter(year_season_baseline == year_season_ndvi) %>%
  as.data.frame()

## 3. save and share with collaborator 
f <- file.path(dir, 'SocialMind', 'output', paste0('sm_postcode_300m_NDVI_season_', yrs, '_', ymd, '.xlsx')); f
writexl::write_xlsx(x = sm_ndvi, path = f)
```



