---
title: "Untitled"
output: html_document
date: "2025-09-16"
---

```{r setup}

# To clear your environment 
remove(list = ls())

# load common packages
library(here)
here()
source(here('code', 'func_packages.R'))

# additional packages
library(forcats)
library(sf)
library(purrr)
library(RColorBrewer)


# functions
source(here('code', 'func_ggsave.R'))
source(here('code', 'func_get_color_scale.R'))

theme_set(theme_bw(base_size = 12))

ymd   <- format(Sys.time(), "%Y%m%d"); ymd



## dir
dir_ucm_out <- 'G:/Shared drives/Wellcome Trust Project Data/2_postprocess_intermediate/UCM_official_runs'
dir.fig <- here('figures')

```

## Data


### help data 

```{r}

f <- file.path(dir_ucm_out, 'ucm_output_postprocess', 'aoi_sf.rds')
aoi <- readRDS(f)

#' lsoa data with quintiles info, which was generated by `socio-economic-data-ES-equity.Rmd`
f <- './data/Social_Vulnerability_Index_london_q.gpkg'
aoi_lsoa <- st_read(f) 
```


### csv data from zonal stats

```{r - chesla - historical}
# --- 0) Inputs ---
dir.ch <- "E:/_data/chelsa02/clipped_london_stats/"
dir.wc <- "E:/_data/GCMs/clipped/stats/"


spatial_unit <- 'borough'
# spatial_unit <- 'lsoa'
  
  
# --- 1) Baseline (observed) CSV (read FIRST, since we join to it) ---

# 1) List CHELSA tasmax CSVs
files <- list.files(
  path = dir.ch,
  pattern = paste0("^", spatial_unit, "_stats_CHELSA_.*tasmax_.*\\.csv$"),
  full.names = TRUE
) |> sort()

# 2) Helper to parse year (and month) from filename
# expects: ..._tasmax_MM_YYYY_...
parse_meta_ch <- function(path) {
  bn <- basename(path)
  m  <- str_match(bn, "tasmax_(\\d{2})_(\\d{4})")
  tibble(
    # file  = basename(path),
    month = as.integer(m[, 2]),
    year  = as.integer(m[, 3])
  )
}

# 3) Read & combine
df_ch <- map_dfr(files, function(f) {
  meta <- parse_meta_ch(f)
  read_csv(f, show_col_types = FALSE) |>
    mutate(
      # source_file = basename(f),
      year  = meta$year,
      month = meta$month)
})



## subset the baseline year ---
df1 <- df_ch %>%
  filter(year == 2021) %>%
  mutate(year_base = 2021) %>%
  select(-year, -month)


```


```{r}

# --- 2) Helper: parse model name from filename ---
# expects names like: borough_stats_wc2.1_30s_tmax_ACCESS-CM2_ssp370_2041-2060_London.csv
parse_meta <- function(paths) {
  bn <- basename(paths)
  m  <- str_match(bn, "tmax_([^_]+)_(ssp\\d+)_(\\d{4}-\\d{4})")

  # cols: 1=full match, 2=model, 3=scenario, 4=period
  tibble(
    file     = paths,
    model    = m[, 2] %||% NA_character_,
    scenario = m[, 3] %||% NA_character_,
    period   = m[, 4] %||% NA_character_
  )
}

# helper: %||% (replace NA from failed matches)
`%||%` <- function(x, y) ifelse(is.na(x), y, x)

# --- 3) Helper: join one model file to baseline and compute diff --------------
join_model <- function(model_csv, df_baseline) {
  
  meta <- parse_meta(model_csv)
  
  readr::read_csv(model_csv, show_col_types = FALSE) %>%
    dplyr::inner_join(df_baseline, by = "borough", suffix = c("_s", "_b")) %>%
    dplyr::mutate(
      model    = meta$model,
      scenario = meta$scenario,
      period   = meta$period,
      mean_diff = mean_s - mean_b
    ) %>%
    mutate(period = case_when(
      period == '2021-2040' ~ '2030',
      period == '2041-2060' ~ '2050',
      period == '2061-2080' ~ '2070',
      T                     ~ period
    ))
}

```


  Load borough level stats data. 
  
```{r - worldclim - future}

# --- 4) Collect model files and batch process ---
files <- list.files(
  path = dir.wc,
  pattern = paste0("^", spatial_unit, "_stats_wc2\\.1_.*tmax_.*_ssp.*\\.csv$"),
  full.names = TRUE
)

df_wc <- map_dfr(files, ~ join_model(.x, df1)) 


# update column name depend on different input data
if (spatial_unit == 'borough') {
  geoid_name = 'NAME'
} else {
  geoid_name = 'id'
  aoi <- aoi_lsoa
}

# --- 5) add sf 
df_wc_sf <- aoi %>%
  rename('borough'=geoid_name) %>%
  left_join(df_wc, by = 'borough')


# Optional: ensure a valid CRS for plotting
if (is.na(sf::st_crs(df_wc_sf))) {
  sf::st_crs(df_wc_sf) <- 4326
}


# Ensure factors have a nice order
df_wc_sf <- df_wc_sf %>%
  mutate(
    model  = fct_inorder(as.factor(model)),
    period = fct_inorder(as.factor(period))
  )

```




```{r - change + summary}

df_ch_sub <- df_ch %>%
  select(any_of(c("borough", "year", "month", "mean"))) %>%
  mutate(scenario = 'baseline')



df_wc_summ <- df_wc_sf %>%
  group_by(borough, scenario, period) %>%
  summarise(
    mean = mean(mean_s, na.rm = TRUE),
    mean_diff_avg = mean(mean_diff, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  rename(year = period) %>%
  mutate(month = 7) 


## add equity data to the result
temp_change_group <- aoi_lsoa %>%
  rename('geoid' = 'id') %>%
  mutate(geoid = as.character(geoid)) %>%
  left_join(., df_wc_summ %>% 
              st_drop_geometry() %>%
              rename('geoid' = 'borough'), 
            by = 'geoid')

# save this data for later analysis 
f <- here('data/temp_svi.RDS')
saveRDS(object = temp_change_group, file = f)



df_wc_summ_sub <- df_wc_summ %>%
  st_drop_geometry() %>%
  ## make sure the two df have the same col names
  select(any_of(names(df_ch_sub)))


# names(df_ch_sub)
# names(df_wc_summ_sub)


## combine the two 
df_ch_wc <- rbind(df_ch_sub, df_wc_summ_sub)


library(tidyr)
df_ch_wc_w <- df_ch_wc %>%
  as.data.frame() %>%
  filter(year > 2020) %>%
  filter(scenario %in% c('baseline', 'ssp370') ) %>%
  select(-scenario) %>%
  pivot_wider(names_from = 'year', values_from = 'mean')
```


### plot

```{r - boxplot - change over time}

# Which column holds the temperature?
value_col <- "mean"        # or "air_temperature"

dodge2_width = 0.8  # how far apart the groups are dodged
padding_bar = 0.3   # spacing between boxes within the same year
pd2 <- position_dodge2(width = dodge2_width, padding = padding_bar, preserve = "single")

p <- 
  df_ch_wc %>%
  filter(year >= 2020) %>%
  filter(year != 2020) %>% ## remove one year - not showing in the figure
  # mutate(year = factor(year)) %>% # factor(year) on x-axis ensures discrete spacing
  # mutate(year = as.numeric(year)) %>%
  ggplot(., aes(x = factor(year),  
                y = .data[[value_col]], 
                color = scenario, # outline color by scenario
                # dodge by scenario within each year
                group = interaction(year, scenario))) +
  geom_boxplot(
    # aes(fill = year >= 2030,
    #     # color = scenario, # outline color by scenario
    #   ),
    # 
    # position = position_dodge(width = 0.75), 
    position = pd2,
    show.legend = FALSE,
    outlier.shape = NA, 
    width = 0.6,        # thinner boxes read better when dodged
    # linewidth = 0.2, 
    # fill = "grey85", 
    # color = "grey40", 
    alpha = 0.4) +
  
  
  stat_summary(
    fun = mean, 
    geom = "point", 
    # position = pd2,
    position = position_dodge(width = 0.65), # it is odd that pd2 would not work well here
    shape = 18, 
    # color = "#f03b20", 
    size = 2, alpha = .7) +
  # mean label (one decimal)
  stat_summary(
    fun = mean, 
    geom = "text", 
    # position = pd2,
    position = position_dodge(width = 0.65*3), # likewise, this allows better control 
    # color = "#f03b20", 
    aes(label = after_stat(sprintf("%.1f", y)),
        hjust = case_when(
          scenario == "baseline" ~ 1.5,        # customize hjust based on the group
          T ~ 0.5)
    ), 
    show.legend = F,
    # vjust = -4,  # above the bar 
    # hjust = 0.5,  # Center the text
    size = 3
  ) +
  
  # fill colors for the condition
  scale_fill_manual(
    values = c(`FALSE` = "grey75", `TRUE` = "grey95"),  # pick your future color
    name   = NULL, 
    labels = c(`FALSE` = "≤ 2030", `TRUE` = "> 2030")
  ) +
  
  # Color scale for scenario (add your specific colors)
  scale_color_manual(
    name = NULL,
    values = c("baseline" = "#4e79a7", "ssp370" = "#f28e2b", "ssp585" = "#e15759")) +
  
  # # optional: show all borough points with jitter
  # geom_point(position = position_jitter(width = 0.15, height = 0),
  #            alpha = 0.2, 
  #            # size = 1.2, 
  #            color = "grey35") +
  # show Mean point per year/scenario
  
  
  scale_y_continuous(expand = expansion(mult = c(0.02, 0.10))) +
  labs(
    x = "Year",
    y = "Temperature (°C)",
    # title = "July temperature by year"
  ) +
  # theme_minimal(base_size = 11) +
  theme_bw(base_size = 11) +
  theme(panel.grid.major.x = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position = c(0.2, 0.9))

n_scenario <- df_ch_wc %>%
  ungroup() %>%
  filter(year >= 2030) %>%
  pull(scenario) %>%
  unique() %>%
  length()

# if (n_scenario>1){
#   p <- p + 
#     facet_wrap(~scenario)
# }

p

# --- 3) save ---
f <- paste0(dir.fig, "/T_change_", spatial_unit, "_overTime_", n_scenario, "s_", ymd, ".png")
ggsave( filename = f, plot = p, width = 3.5, height = 5.5, units = "in", dpi = 300)

```


```{r - tmap, eval=FALSE, include=FALSE}

library(tmap)


# --- 6) facet map using tmap (mean_diff by model) ---

# Make a symmetric color scale around 0 so warming/cooling are comparable across facets
max_abs <- max(abs(df_wc_sf$mean_diff), na.rm = TRUE)
# choose nice breaks (e.g., every 0.5 °C); tweak step to your data spread
step <- if (max_abs <= 2) 0.5 else if (max_abs <= 5) 1 else 2
brks <- seq(-ceiling(max_abs/step)*step, ceiling(max_abs/step)*step, by = step)

# tmap style
tmap_mode("plot")  # static plotting

tm_map_diff <- 
  tm_shape(df_wc_sf) +
  tm_fill(
    col = "mean_diff",
    # style = "fixed",
    # breaks = brks,
    style = "quantile", # "equal", "pretty", "quantile", "kmeans"
    n = 8, 
    # breaks = brks,
    palette = "YlOrRd",                  # diverging, blue=cooler, red=warmer
    title = "Δ Temp (°C)\n(model - baseline)",
    legend.format = list(digits = 1),
    legend.reverse = TRUE,
    colorNA = "grey90"
  ) +
  tm_borders(col = "grey40", lwd = 0.5) +
  tm_facets(by = "model", ncol = 2, free.scales = FALSE) +  # same legend across facets
  tm_layout(
    legend.outside = F,
    legend.position = c("right", "bottom"), # inside the map: left/top/right/bottom
    legend.format = list(digits = 1),
    panel.labels.rot = 0,
    frame = FALSE
  )

tm_map_diff

# --- Save (optional) ---
# tmap automatically sizes facets; set width/height to suit your grid
tmap_save(
  tm = tm_map_diff,
  filename = file.path(dir.fig, paste0("T_change_", spatial_unit, "_by_model-quantile2.png")),
  width = 7, height = 5, units = "in", dpi = 300
)

# --- Variants ---
# 1) If you want to facet by scenario instead (if present as a column):
# tm_facets(by = "scenario", ncol = 3, free.scales = FALSE)

# 2) Map the model's absolute mean (mean_s) instead of difference:
# tm_fill("mean_s", style = "quantile", n = 5, palette = "YlOrRd", title = "Model mean (°C)")

# 3) Add borough labels (centroids) sparingly:
# centers <- sf::st_point_on_surface(df_wc_sf)
# tm_shape(centers) + tm_text("borough", size = 0.5, auto.placement = TRUE, bg.color = "white", bg.alpha = 0.5)
```

```{r - ggplot}

library(forcats)
library(scales)

# --- 1) make global quantile bins (8 classes) ---
probs   <- seq(0, 1, length.out = 9)
brks    <- quantile(df_wc_sf$mean_diff, probs = probs, na.rm = TRUE, type = 7)
brks    <- unique(brks)                           # guard against duplicate quantiles
labs    <- sprintf("%s–%s",
                   format(round(brks[-length(brks)], 1), nsmall = 1),
                   format(round(brks[-1],          1), nsmall = 1))

df_plot <- df_wc_sf %>%
  mutate(
    mean_diff_bin = cut(mean_diff,
                        breaks = brks,
                        include.lowest = TRUE,
                        labels = labs)
  )

# --- 2) plot with ggplot (facets by model) ---
p <- ggplot(df_plot) +
  geom_sf(aes(fill = mean_diff_bin), color = "grey40", linewidth = 0.3) +
  # facet_wrap(~ model, ncol = 2) +
  facet_grid(rows = vars(period), cols = vars(model)) +
  scale_fill_brewer(
    palette = "YlOrRd",
    na.value = "grey90",
    drop = FALSE,
    name = "ΔT (°C)"
  ) +
  guides(fill = guide_legend(
    reverse = F,
    nrow = 1, # all keys in a single row
    byrow = TRUE)) +  # reverse legend order

  theme_minimal(base_size = 11) +
  theme(
    panel.grid = element_blank(), 
    axis.text = element_blank(),
    # legend.position = c(0.85, 0.02), # inside bottom-right; tweak or set "right"
    legend.position = "bottom",
    legend.box = "horizontal",
    legend.key.size = unit(10, "pt"),
    legend.title = element_text(lineheight = 0.9)
  )

p

# --- 3) save ---
ggsave(
  filename = file.path(dir.fig, paste0("T_change_", spatial_unit, "_by_model-quantile_ggplot_years.png")),
  plot = p, width = 7, height = 5, units = "in", dpi = 300
)

```


### avg across models

```{r - bin}

# --- 1) make global quantile bins (8 classes) ---
probs   <- seq(0, 1, 0.1)
brks    <- quantile(df_wc_summ$mean_diff_avg, probs = probs, na.rm = TRUE, type = 7)
brks    <- unique(brks)                           # guard against duplicate quantiles
labs    <- sprintf("%s–%s",
                   format(round(brks[-length(brks)], 1), nsmall = 1),
                   format(round(brks[-1],          1), nsmall = 1))

df_plot <- df_wc_summ %>%
  mutate(
    mean_diff_bin = cut(mean_diff_avg,
                        breaks = brks,
                        include.lowest = TRUE,
                        labels = labs)
  )

# --- make enough colors (length = number of bins) ---
n_bins <- length(levels(df_plot$mean_diff_bin))
pal    <- colorRampPalette(brewer.pal(9, "YlOrRd"))(n_bins)  # extends YlOrRd beyond 9



# --- 2) plot with ggplot (facets by model) ---

facet_ncol = 2; hist2_x = 0.76; hist1_y = 0.06; hist2_y = 0.06; hist_w=0.2; hist_h=0.20; legend_x =0.47; legend_y=0.20; p_h=4
facet_ncol = 1; hist2_x = 0.03; hist1_y = 0.50; hist2_y = 0.00; hist_w=0.4; hist_h=0.15; legend_x =0.88; legend_y=0.55; p_h=5.7


p_map <- ggplot(df_plot) +
  geom_sf(aes(fill = mean_diff_bin), color = "grey40", linewidth = 0.3) +
  facet_wrap(~ year, ncol = facet_ncol) +
  scale_fill_manual(values = pal, drop = FALSE,name = "ΔT (°C)") +
  # scale_fill_viridis_d(name = "ΔT (°C)", option = "C", drop = FALSE) +
  guides(fill = guide_legend(reverse = TRUE)) +  # reverse legend order
  theme_minimal(base_size = 11) +
  theme(
    panel.grid = element_blank(), 
    axis.text = element_blank(),
    legend.position = c(legend_x, legend_y),              # inside bottom-right; tweak or set "right"
    # legend.justification = c("right", "bottom"),
    legend.key.size = unit(9, "pt"),
    legend.title = element_text(lineheight = 0.9)
  )

# p_map



# --- the inset histogram ---
n_bins <- 5

p_hist1 <- 
  df_plot %>%
  filter(year == '2050') %>%
  ggplot(., aes(x = mean_diff_avg)) +
  geom_histogram(bins = n_bins, fill = "grey60", colour = 'white', alpha = 0.5) +
  # add count labels per bin
  geom_text(
    stat = "bin",
    bins = n_bins,
    aes(label = ifelse(after_stat(count) > 0, after_stat(count), "")),
    vjust = -0.25,
    size = 2
  ) +
  scale_y_continuous(expand = expansion(mult = c(0.0, 0.18))) +  # headroom for labels
  labs(x = "ΔT (°C)", y = "Count") +
  theme_minimal(base_size = 8) +
  theme(
    panel.background = element_rect(fill = NA, color = NA),
    plot.margin = margin(0, 0, 0, 0), 
    panel.grid = element_blank(),
    axis.title = element_text(size = 8),
    axis.text  = element_text(size = 7)
  )


p_hist2 <- 
  df_plot %>%
  filter(year == '2070') %>%
  ggplot(., aes(x = mean_diff_avg)) +
  geom_histogram(bins = n_bins, fill = "grey60", colour = 'white', alpha = 0.5) +
  # add count labels per bin
  geom_text(
    stat = "bin",
    bins = n_bins,
    aes(label = ifelse(after_stat(count) > 0, after_stat(count), "")),
    vjust = -0.3,
    size = 2
  ) +
  scale_y_continuous(expand = expansion(mult = c(0.0, 0.15))) +  # headroom for labels
  labs(x = "ΔT (°C)", y = "Count") +
  theme_minimal(base_size = 8) +
  theme(
    panel.background = element_rect(fill = NA, color = NA),
    plot.margin = margin(0, 0, 0, 0), 
    panel.grid = element_blank(),
    axis.title = element_text(size = 8),
    axis.text  = element_text(size = 7)
  )


# --- overlay: x/y/width/height are in [0,1] relative to the figure ---
library(cowplot)
p_final <- ggdraw(p_map) +
  draw_plot(p_hist1, x = 0.03,    y = hist1_y, width = hist_w, height = hist_h) +
  draw_plot(p_hist2, x = hist2_x, y = hist2_y, width = hist_w, height = hist_h)

p_final



# --- 3) save ---
f <- paste0(dir.fig, '/T_change_', spatial_unit, '_by_model-quantile_ggplot_avg_years-v-', ymd, '.png')
ggsave(filename = f, plot = p_final, width = 3.5*facet_ncol, height = p_h, units = "in", dpi = 300)

```




```{r - cont}

ggplot(df_plot) +
  geom_sf(aes(fill = mean_diff_avg), color = "grey40", linewidth = 0.3) +
  facet_wrap(~ year, ncol = 2) +
  scale_fill_distiller(
    name = "ΔT (°C)",
    palette = "YlOrRd",   # Brewer palette
    direction = 1,        # -1 to reverse
    na.value = "grey90",
    limits = range(df_plot$mean_diff_avg, na.rm = TRUE),  # optional; fixes range
    oob = scales::squish
  ) +
  
  # scale_fill_viridis_c(name = "ΔT (°C)", option = "C", na.value = "grey90") +
  # continuous guide (colorbar) and reverse if desired
  # guides(fill = guide_colorbar(
  #   # reverse   = TRUE,
  #   ticks     = TRUE
  # )) +
  
  
  ## --- to show Percentile --- 
  # scale_fill_gradientn(
  #   colours = colorRampPalette(RColorBrewer::brewer.pal(9, "YlOrRd"))(256),
  #   name    = "Percentile",
  #   breaks  = brks,                      # legend ticks at quantiles
  #   labels  = percent(probs),            # "0%", "10%", "25%", ...
  #   na.value = "grey90",
  #   oob = squish
  # ) +
  # guides(fill = guide_colorbar(barheight = unit(70, "pt"), barwidth = unit(8, "pt"))) +
  
  theme_minimal(base_size = 11) +
  theme(
    panel.grid = element_blank(), 
    axis.text = element_blank(),
    legend.position = c(0.55, 0.02),              # inside bottom-right; tweak or set "right"
    legend.justification = c("right", "bottom"),
    legend.key.size = unit(10, "pt"),
    legend.title = element_text(lineheight = 0.9)
  )

ggsave(
  filename = file.path(dir.fig, paste0("T_change_", spatial_unit, "_by_model-quantile_ggplot_avg_years3-2.png")),
  plot = last_plot(), width = 7, height = 4, units = "in", dpi = 300
)

```



